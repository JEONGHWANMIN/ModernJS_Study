# 10. 객체 리터럴

## 10.1 객체란?
> 자바스크립트의 객체는 키(key)과 값(value)으로 구성된 프로퍼티(Property)들의 집합이다.
> 또한 원시 값은 변경이 불가능한 값이지만, 객체는 변경이 가능한 값이다.
 
 프로퍼티의 값으로 자바스크립트에서 사용할 수 있는 모든 값을 사용할 수 있다. 자바스크립트의 함수는 일급 객체이므로 값으로 취급할 수 있다. 따라서 프로퍼티 값으로 함수를 사용할 수도 있으며 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 **메서드** 라 부른다.

 자바스크립트의 객체는 객체지향의 상속을 구현하기 위해 **“프로토타입(prototype)”** 이라고 불리는 객체의 프로퍼티와 메서드를 상속받을 수 있다. 이 프로토타입은 타 언어와 구별되는 중요한 개념이다.
<hr/>

## 10.2 객체 리터럴에 의한 객체 생성
 클래스 기반의 객체지향 언어는 클래스를 사전에 정의하고 필요한 시점에 `new` 연산자와 함께 `constructor` 를 호출하여 인스턴스를 생성하는 방식으로 객체를 생선한다. 

 자바스크립트는 프로토타입 기반 객체지향 언어로서 다양한 객체 생성 방법을 지원한다.
 - 객체 리터럴
 - Object 생성자 함수
 - 생성자 함수
 - Object.creat 메서드
 - 클래스 (ES6)

> 리터럴: 사람이 이해할 수 있는 문자 또는 약소된 기호를 사용하여 값을 생성하는 표기법.

 객체 리터럴은 {} 내에 0개 이상의 프로퍼티를 정의한다. 만약 {} 내에 프로퍼티를 정의하지 않으면 빈 객체가 생성된다.

 객체 리터럴의 {} 는 코드블럭이 아니라 값으로 평가되는 표현식이기 때문에, ;을 붙여줘야 한다.
 객체 리터럴은 유연함과 강력함을 대표하는 객체 생성 방식으로 `new` 연산자와 함께 생성자를 호출할 필요가 없이, 리터럴로 객체를 생성한다. 

 객체 리터럴에 프로퍼티를 포함시켜 객체를 생성함과 동시에 프로퍼티를 만들 수도 있고, 객체를 생성한 이후에 프로퍼티를 동적으로 추가할 수도 있다.
<hr/>

## 10.3 프로퍼티
> 객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다. 
 
 프로퍼티는 프로퍼티 키로 유일하게 식별할 수 있다. 즉, 프로퍼티 키는 프로퍼티를 식별하기 위한 **식별자(identifier)** 다. 프로퍼티 키의 명명 규칙과 프로퍼티 값으로 사용할 수 있는 값은 아래와 같다.

 - **프로퍼티 키** : 빈 문자열을 포함하는 모든 문자열 또는 symbol 값
 - **프로퍼티 값** : 모든 값

 프로퍼티 키에 문자열이나 symbol 값 이외의 값을 지정하면 암묵적으로 타입이 변환되어 문자열이 된다. 이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다. 배열과는 달리 객체는 프로퍼티를 열거할 때 순서를 보장하지 않는다.
<hr/>

## 10.4 메서드
> 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메서드라 부른다. 즉, 메서드는 객체에 제한되어 있는 함수를 의미한다.

 자바스크립트에서 함수는 '일급 객체' 이다. 따라서 값으로 취급할 수 있기 때문에, 프로퍼티 값으로 사용 할 수 있다. 
<hr/>

## 10.5 프로퍼티 접근
 프로퍼티에 접근하는 방식은 다음과 같다.

 - 마침표 프로퍼티 연산자 (.) 를 사용하는 **마침표 표기법**
 - 대괄호 프로퍼티 접근 연산자 ([...]) 를 사용하는 **대괄호 표기법**

 프로퍼티 키가 유효한 자바스크립트 이름이고 예약어가 아닌 경우 프로퍼티 값은 마침표 표기법, 대괄호 표기법 모두 사용할 수 있다.

 프로퍼티 이름이 유효한 자바스크립트 이름이 아니거나 예약어인 경우 프로퍼티 값은 대괄호 표기법으로 읽어야 한다. 대괄호 ([...]) 표기법을 사용하는 경우, **대괄호 내에 들어가는 프로퍼티 이름은 반드시 따옴표로 감싼 문자열이어야 한다.**

 객체에 존재하지 않는 프로퍼티를 참조하면 `undefined`를 반환한다.
<hr/>

## 10.6 프로퍼티 값 갱신
> 객체가 소유하고 있는 프로퍼티에 새로운 값을 할당하면 프로퍼티 값은 갱신된다.

 ```js
 var person = {
  'first-name': 'Ung-mo',
  'last-name': 'Lee',
  gender: 'male',
 };

 person['first-name'] = 'Kim';
 console.log(person['first-name'] ); // 'Kim'
 ```
<hr/>

## 10.7 프로퍼티 동적 생성
> 객체가 소유하고 있지 않은 프로퍼티 키에 값을 할당하면 하면 주어진 키와 값으로 프로퍼티를 생성하여 객체에 추가한다.

 ```js
 var person = {
  'first-name': 'Ung-mo',
  'last-name': 'Lee',
  gender: 'male',
 };

 person.age = 20;
 console.log(person.age); // 20
 ```
<hr/>

## 10.8 프로퍼티 삭제
> `delete` 연산자를 사용하면 객체의 프로퍼티를 삭제할 수 있다. 이때 피연산자는 프로퍼티 키이어야 한다.

 ```js
 var person = {
  'first-name': 'Ung-mo',
  'last-name': 'Lee',
  gender: 'male',
 };

 delete person.gender;
 console.log(person.gender); // undefined

 delete person;
 console.log(person); // Object {first-name: 'Ung-mo', last-name: 'Lee'}
 ```
<hr/>

## 10.9 ES6 에서 추가된 객체 리터럴의 확장 기능
> ES6에서는 객체 리터럴 프로퍼티 기능을 확장하여 더욱 간편하고 동적인 객체 생성 기능을 제공한다.

 ### 10.9.1 프로퍼티 축약 표현
 **ES5** 에서 객체 리터럴의 프로퍼티는 프로퍼티 이름과 프로퍼티 값으로 구성된다. 프로퍼티의 값은 변수에 할당된 값일 수도 있다.

 ```js
 // ES5
 var x = 1, y = 2;

 var obj = {
  x: x,
  y: y
 };

console.log(obj); // { x: 1, y: 2 }
 ```

 **ES6** 에서는 프로퍼티 값으로 변수를 사용하는 경우, 프로퍼티 이름을 생략(Property shorthand)할 수 있다. 이때 프로퍼티 이름은 변수의 이름으로 자동 생성된다.

 ```js
 // ES6
 let x = 1, y = 2;

 const obj = { x, y };

 console.log(obj); // { x: 1, y: 2 } 
 ```

 ### 10.9.2 계산된 프로퍼티 이름
 문자열 또는 문자열로 변환 가능한 값을 반환하는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수 있다. 단, 프로퍼티 키로 사용할 표현식을 대괄호([…])로 묶어야 한다. 이를 계산된 프로퍼티 이름(Computed property name)이라 한다.
 
 **ES5** 에서 프로퍼티 키를 동적으로 생성하려면 객체 리터럴 외부에서 대괄호([…]) 표기법을 사용해야 한다.

 ```js
 // ES5
 var prefix = 'prop';
 var i = 0;

 var obj = {};

 obj[prefix + '-' + ++i] = i;
 obj[prefix + '-' + ++i] = i;
 obj[prefix + '-' + ++i] = i;

 console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
 ```
 **ES6** 에서는 객체 리터럴 내부에서도 프로퍼티 키를 동적으로 생성할 수 있다.

 ```js
 // ES6
 const prefix = 'prop';
 let i = 0;

 const obj = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i
 };

 console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
 ```

 ### 10.9.3 메서드 축약 표현
 ES5에서 메서드를 선언하려면 프로퍼티 값으로 함수 선언식을 할당한다.

 ```js
 // ES5
 var obj = {
  name: 'Lee',
  sayHi: function() {
    console.log('Hi! ' + this.name);
  }
 };

 obj.sayHi(); // Hi! Lee
 ```

 ES6에서는 메서드를 선언할 때, function 키워드를 생략한 축약 표현을 사용할 수 있다.

 ```js
 // ES6
 const obj = {
  name: 'Lee',
  // 메서드 축약 표현
  sayHi() {
    console.log('Hi! ' + this.name);
  }
 };

 obj.sayHi(); // Hi! Lee
 ```
 <hr/>