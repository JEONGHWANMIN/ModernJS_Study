# 13. 스코프

## 13.1 스코프란

> 스코프(Scope, 유효범위)는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적인 개념이다.
> 스코프는 참조 대상 식별자(identifier, 변수, 함수의 이름과 같이 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름)를 찾아내기 위한 규칙이다. 자바스크립트는 이 규칙대로 식별자를 찾는다.

모든 식별자는 자신이 선언된 위치에 따라 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 스코프라 한다.
즉, 스코프는 식별자가 유효한 범위를 말한다.

- 식별자 결정: 이름이 같은 변수 중, 어떤 변수를 참조해야 하는지 결정하는 것.
  따라서 스코프란 식별자를 검색할 때 사용하는 규칙이라고 할 수 있다.

식별자는 고유한 이름으로, 서로 구별되어야 하므로 유일해야 한다. 하나의 값은 유일한 식별자에 연결되어야 한다.
따라서 스코프가 없으면 같은 이름의 변수를 사용할 수 없다.

<hr/>

## 13.2 스코프의 종류

자바스크립트에서 스코프를 구분해보면 다음과 같이 2가지로 나눌 수 있다.

- 전역 스코프 (Global scope)
  : 코드 어디에서든지 참조할 수 있다.

- 지역 스코프 (Local scope or Function-level scope)
  : 함수 코드 블록이 만든 스코프로 함수 자신과 하위 함수에서만 참조할 수 있다.

모든 변수는 스코프를 갖는다. 변수의 관점에서 스코프를 구분하면 다음과 같이 2가지로 나눌 수 있다.

- 전역 변수 (Global variable)
  : 전역에서 선언된 변수이며 어디에든 참조할 수 있다.

- 지역 변수 (Local variable)
  : 지역(함수) 내에서 선언된 변수이며 그 지역과 그 지역의 하부 지역에서만 참조할 수 있다.

변수는 선언 위치(전역 또는 지역)에 의해 스코프를 가지게 된다. 즉, 전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수이고, 지역(자바스크립트의 경우 함수 내부)에서 선언된 변수는 지역 스코프를 갖는 지역 변수가 된다.

전역 스코프를 갖는 전역 변수는 전역(코드 어디서든지)에서 참조할 수 있다. 지역(함수 내부)에서 선언된 지역 변수는 그 지역과 그 지역의 하부 지역에서만 참조할 수 있다.

<hr/>

## 13.3 스코프 체인

> 함수는 중첩될 수 있다. (중첩함수 / 외부함수) 따라서 지역스코프도 중첩될 수 있다. 이는 스코프가 함수의 중첩에 의해 계층적 구조를 가진다는 것을 의미한다.
> 이처럼 스코프가 계층적으로 연결된 것을 스코프 체인이라고 한다.

변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여, 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.
이러한 스코프 체인은 물리적인 실체 (렉시컬 환경)로 존재한다.

### 13.3.1 스코프 체인에 의한 변수 검색

> 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만, 하위 스코프에소 유요한 변수를 상위스코프에서 참조할 수 없다.

스코프 체인의 계층적 구조는 상속과도 유사하다. (자식이 부모의 자산을 사용할 수 있지만, 반대는 불가하다.) 스코프의 검색은 절대로 하위 스코프로 내려가면서 이뤄지지 않는다.

### 13.3.2 스코프 체인에 의한 함수 검색

함수 역시 식별자에 해당하기 때문에 스코프를 갖는다. 따라서 스코프를 "식별자를 검색하는 규칙" 이라고 표현 할 수 있다.

<hr/>

## 13.4 함수레벨 스코프

대부분의 C-family language는 블록 레벨 스코프(block-level scope)를 따른다. 블록 레벨 스코프란 코드 블록({…})내에서 유효한 스코프를 의미한다. 여기서 “유효하다”라는 것은 “참조(접근)할 수 있다”라는 뜻이다.

하지만 자바스크립트는 함수 레벨 스코프(function-level scope)를 따른다. 함수 레벨 스코프란 함수 코드 블록 내에서 선언된 변수는 함수 코드 블록 내에서만 유효하고 함수 외부에서는 유효하지 않다(참조할 수 없다)는 것이다.

단, ECMAScript 6에서 도입된 let keyword를 사용하면 블록 레벨 스코프를 사용할 수 있다.

<hr/>

## 13.5 렉시컬 스코프

```js
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?
```

위 예제의 실행 결과는 함수 bar의 상위 스코프가 무엇인지에 따라 결정된다. 두가지 패턴을 예측할 수 있는데 첫번째는 함수를 어디서 호출하였는지에 따라 상위 스코프를 결정하는 것이고 두번째는 함수를 어디서 선언하였는지에 따라 상위 스코프를 결정하는 것이다. 첫번째 방식으로 함수의 상위 스코프를 결정한다면 함수 bar의 상위 스코프는 함수 foo와 전역일 것이고, 두번째 방식으로 함수의 스코프를 결정한다면 함수 bar의 스코프는 전역일 것이다.

프로그래밍 언어는 이 두가지 방식 중 하나의 방식으로 함수의 상위 스코프를 결정한다. 첫번째 방식을 동적 스코프(Dynamic scope)라 하고, 두번째 방식을 렉시컬 스코프(Lexical scope) 또는 정적 스코프(Static scope)라 한다. 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.

렉시컬 스코프는 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정된다. 자바스크립트는 렉시컬 스코프를 따르므로 함수를 선언한 시점에 상위 스코프가 결정된다. 함수를 어디에서 호출하였는지는 스코프 결정에 아무런 의미를 주지 않는다. 위 예제의 함수 bar는 전역에 선언되었다. 따라서 함수 bar의 상위 스코프는 전역 스코프이고 위 예제는 전역 변수 x의 값 1을 두번 출력한다.

<hr/>
