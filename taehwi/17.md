# 17. 생성자 함수에 의한 객체 생성

## 17.1 `Object` 생성자 함수

<br>

> `new` 연산자와 함께 `Object` 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다.
> 이후 프로퍼티나 메서드를 추가하여 환성 할 수 있다.

 <br>

- _생성자 함수: `new` 연산자와 함께 호출하여 인스턴스를 생성하는 함수_
- _`Object` 이외에도 여러 빌트인 생성자 함수를 제공한다_

<br>

---

<br>

## 17.2 생성자 함수

<br>

### 17.2.1 객체 리터럴에 의한 객체 생성 방식의 문제점

 <br>
  
  - *편리하지만, 단 하나의 객체만을 생성한다* <sup>(비효율적) 
 
 <br>

---

 <br>

### 17.2.2 생성자 함수에 의한 객체 생성 방식의 장점

 <br>
  
  - *마치 템플릿처럼 함수를 이용해 동일한 프로퍼티 구조의 객체 여러개를 간편하게 생성 가능하다*
  - *`new` 연산자와 함께 호출하지 않으면 일반 함수로 동작한다*
 
 <br>

---

 <br>
 
 ### 17.2.3 생성자 함수의 인스턴스 생성 과정
 <br>
 
 > 생성자 함수의 역할은 **'인스턴스를 생성하는 것'** 과 **'생성된 인스턴스를 초기화 하는 것'** 이다.

 <br>
 
 #### **1. 인스턴스 생성과 `this` 바인딩**

: _암묵적으로 빈 객체가 생성된다. 이 빈 객체가 생성자 함수가 생성한 인스턴스이다. 따라서, 인스턴스는 `this` 에 바인딩된다. 생성자 함수 내부의 `this` 가 생성자 함수가 생성할 인스턴스를 가리키는 이유가 바로 이것이다. 이 처리는 함수 몸체의 코드가 한 줄씩 실행되는 런타임 이전에 실행된다._

 <br>

#### **2. 인스턴스 초기화**

: _생성자 함수에 기술되어 있는 코드가 한 줄씩 실행되어 `this` 에 바인딩되어 있는 인스턴스를 초기화 한다._

 <br>
 
 #### **3. 인스턴스 반환**

: _생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 `this` 가 암묵적으로 반환된다. 만약 `this` 가 아닌 다른 객체를 명시적으로 반환하면 `this` 가 반환되지 못하고 `return` 문에 명시한 객체가 반환된다. 하지만 명시적으로 원시값을 반환하면 암묵적으로 `this` 가 반환된다._

 <br>

---

 <br>
 
 ### 17.2.4 내부 메서드 `[[Call]]` & `[[Construct]]`
 <br>
 
 > 함수는 일반 객체이지만 일반 객체와 다르다. 일반 객체는 호출할 수 없지만, 함수는 호출이 가능하다. 따라서 함수는 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드는 물론이고, 함수 객체를 위한 내부 슬롯과 내부 메서드를 추가로 가지고 있다.

 <br>

- _`callable` : 내부 메서드 `[[Call]]` 을 가진 함수_
  <sup>(호출 할 수 있는 객체, 즉 함수)
  <br>

- _`constructor` : 내부 메서드 `[[Construct]]` 를 가진 함수_
  <sup>(생성자 함수로서 호출할 수 있는 함수)

- _`non-constructor` : 내부 메서드 `[[Construct]]` 를 가지지 않은 함수_
  <sup>(객체를 생성자 함수로서 호출할 수 없는 함수)

 <br>

---

 <br>

### 17.2.5 `constructor` 와 `non-constructor` 의 구분

 <br>

- _`constructor` : 함수 선언문, 함수 표현식, 클래스_
  <br>

- _`non-constructor` : 메서드, 화살표 함수_

 <br>

---

 <br>

### 17.2.6 `new` 연산자

 <br>
 
 `new` 연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작한다. 다시 말해, 함수 객체의 내부 메서드 `[[Call]]` 이 호출되는 것이 아니라 `[[Construct]]` 가 호출된다. 단, `new` 연산자와 함께 호출하는 함수는 `non-constructor` 가 아닌 `constructor` 이여야 한다.

 <br>

반대로 `new` 연산자 없이 생성자 함수를 호출하면 일반 함수로 호출된다. 함수 객체의 내부 메서드 `[[Construct]]` 가 호출되는 것이 아니라 `[[Call]]` 이 호출된다.

 <br>

일반 함수와 생성자 함수의 특별한 형식적 차이는 없다. 따라서 파스칼 케이스로 명명하여 구별할 수 있도록 노력해야 한다.

 <br>

---

 <br>

### 17.2.7 `new.target`

 <br>
 
 생성자 함수가 `new` 연산자 없이 호출되는 것을 방지하기 위해 파스칼 케이스 컨벤션을 사용한다 해도 실수 할 수 있기 때문에, `ES6` 에서는 `new.targget` 을 지원한다. <sup>(IE  에서는 지원하지 않는다.)

 <br>

함수 내부에서 `new.targget` 을 사용하면 `new` 연산자와 함께 생성자 함수로 호출 되었는지 확인 가능하다. `new` 연산자와 함께 생성자 함수로서 호출되면 함수 내부의 `new.targget` 은 함수 자신을 가리킨다. `new` 연산자 없이 일반 함수로서 호출된 함수 내부의 `new.targget` 은 `undefined` 다.

 <br>

대부분의 빌트인 생성자 함수는 `new` 연산자와 함께 호출되었는지를 확인한 후 적절한 값을 반환한다. 하지만 `String`, `Number`, `Boolean` 생성자 함수는 `new` 연산자와 함께 호출 했을 때 `String`, `Number`, `Boolean` 객체를 생성하여 반환하지만, `new` 연산자 없이 호출하면 문자열, 숫자, 불리언 값을 반환한다. <sup> (이를 통해 데이터 타입을 변환하기도 한다.)

 <br>

---

 <br>
