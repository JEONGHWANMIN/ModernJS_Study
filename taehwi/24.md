# <span style="color: #9575CD;"> 24. 클로저

<br>

- **<span style="color: #9CCC65;"> 클로저는 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 중요한 특성**

<br>

> <span style="color: #FFF176;"> _MDN : ' A Closure is the combination of a function and the lexical environment whitin which that function was declared '_ <sup> ( 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다. )

<br>

```js
const 변수 = "감자";

function 외부함수() {
  const 변수 = "고구마";

  function 내부함수() {
    console.log(변수); // '고구마'
  }

  내부함수();
}

외부함수();

/*
    내부함수는 중첩함수 
    
    ->

    내부함수의 상위 스코프 === 외부함수의 스코프 
    
    -> 

    외부함수의 변수에 접근 가능
 */
```

<br>

```js
const 변수 = "감자";

function 외부함수() {
  const 변수 = "고구마";

  내부함수();
}

function 내부함수() {
  console.log(변수); // '감자'
}

외부함수();

/*
    내부함수는 중첩함수가 아님

    ->

    외부함수에서 내부함수 호출

    ->

    외부함수의 변수에 접근 불가
 */
```

<br>

- **<span style="color: #9CCC65;"> 자바스크립트는 렉시컬 스코프를 따르는 프로그래밍 언어이다.**

<br>

---

<br>

## <span style="color: #9575CD;"> 24.1 렉시컬 스코프

<br>

> <span style="color: #FFF176;"> _자바스크립트 엔진은 함수의 호출이 아니라, 함수의 정의에 따라 상위 스코프를 결정한다. 이를 ' 렉시컬 스코프 ' 라고 한다._

<br>

```js
const 메뉴 = "감자튀김";

function 점심() {
  const 메뉴 = "고구마튀김";

  저녁();
}

function 저녁() {
  console.log(메뉴);
}

점심(); // ?
저녁(); // ?
```

<br>
<span style="color: #FFE082;">
점심 함수와 저녁 함수 모두 전역에서 정의되었다. 따라서 두 함수의 스코프는 모두 전역이다. 함수의 상위스코프는 함수가 정의된 위치에 따라 정적으로 결정되고, 변하지 않는다.

<br>

스코프의 실체는 실행 컨텍스트의 렉시컬 환경이다. 렉시컬 환경은 **<span style="color: #9FA8DA;"> " 외부 렉시컬 환경에 대한 참조 "** 를 통해 상위 렉시컬과 연결되는데, 이것이 **<span style="color: #9FA8DA;"> 스코프 체인** 이다.

<br>

**<span style="color: #F06292;"> " 함수의 상위 스코프를 결정하는 것 " === " 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값을 결정하는 것 "**

<br>

렉시컬 환경의 **<span style="color: #9FA8DA;"> " 외부 렉시컬 환경에 대한 참조 "** 에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경 (위치) 에 의해 결정된다. 이것이 **<span style="color: #9FA8DA;"> 렉시컬 스코프**이다.

<br>

---

<br>

## <span style="color: #9575CD;"> 24.4 클로저의 활용

<br>

> <span style="color: #FFF176;"> _클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다. 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용된다._

<br>

```js
// 전역 변수

// 카운트 상태 변수
let 숫자 = 0;

// 카운트 상태 변경 함수
const 증가 = function () {
  return ++숫자;
};

console.log(증가()); // 1
console.log(증가()); // 2
console.log(증가()); // 3
```

<br>

- **<span style="color: #9CCC65;"> 카운트 상태는 증가 함수가 호출되기 전까지 변경되지 않고 유지되어야 한다.**
- **<span style="color: #9CCC65;"> 이를 위해 카운트 상태는 증가 함수만이 변경 가능해야 한다.**

<br>

<span style="color: #FFE082;"> 위와 같은 전제 조건이 지켜져야 바르게 동작하는 예제이므로, 오류 발생 가능성을 내포하고 있다.

- <span style="color: #9CCC65;"> 카운트 상태가 전역 변수를 통해 관리되고 있음
- <span style="color: #9CCC65;"> 누구나 접근하고 변경이 가능함 (암묵적 결합)

<br>

```js
// 전역 변수 -> 지역 변수

// 카운트 상태 변경 함수
const 증가 = function () {
  // 카운트 상태 변수
  let 숫자 = 0;

  return ++숫자;
};

// 이전 상태를 유지하지 못함
console.log(증가()); // 1
console.log(증가()); // 1
console.log(증가()); // 1
```

<br>

의도치 않은 상태 변경은 방지했으나, 지역 변수가 재 선언되고 0으로 초기화 되기 때문에 이전 상태를 유지하지 못한다.

<br>

```js
// 전역 변수 -> 지역 변수 -> 클로저 사용

// 카운트 상태 변경 함수
const 증가 = (function () {
  // 카운트 상태 변수
  let 숫자 = 0;

  // 클로저
  return function () {
    return ++숫자;
  };
})();

console.log(증가()); // 1
console.log(증가()); // 2
console.log(증가()); // 3
```

<br>

즉시 실행 함수가 호출되고, 반환된 함수가 증가 변수에 할당된다. 이는 상위 스코프인 즉시 실행 함수의 렉시컬 환경을 기억하는 클로저이다.

즉시 실행 함수는 호출 후 소멸되지만, 클로저는 `증가` 변수에 할당되어 호출된다. 또한 즉시 실행 함수는 한 번만 실행되므로 `숫자` 변수가 초기화되지 않는다.

- **<span style="color: #9CCC65;"> 클로저는 상태가 의도치 않게 변경되지 않도록 안전하게 은닉하고, 특정 함수에만 상태 변경을 허용하여 상태를 안전하게 변경하고 유지하기 위해 사용된다.**

<br>

```js
const 카운터 = (function () {
  let 숫자 = 0;

  // 클로저인 메서드를 갖는 객체 반환
  // 객체 리터럴은 스코프를 만들지 않음
  // 아래 메서드들의 상위 스코프는 즉시 실행 함수의 렉시컬 환경

  return {
    // 숫자: 0, 프로퍼티는 퍼블릭하므로 은닉되지 않음
    증가() {
      return ++숫자;
    },
    감소() {
      return 숫자 > 0 ? --숫자 : 0;
    },
  };
})();

console.log(증가()); // 1
console.log(증가()); // 2
console.log(증가()); // 3

console.log(감소()); // 3
console.log(감소()); // 2
console.log(감소()); // 1
```

<br>

즉시 실행 함수가 반환하는 객체 리터럴은 즉시 실행 함수의 실행 단계에서 평가되어 객체가 된다. 객체 리터럴의 중괄호는 코드블럭이 아니므로 스코프를 생성하지 않는다.

따라서 예제의 메서드는 메서드 평가 시점에 실행중인 실행 컨텍스트인 즉시 실행 함수 실행 컨텍스트의 렉시컬 환경이다. 따라서 즉시 실행 함수의 스코프 식별자를 참조한다.

<br>

---
