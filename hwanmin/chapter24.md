# 클로저

클로저 -> 자바스크립트 개념이 아니다.

함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 특성이다.

## 24.1 렉시컬 스코프

함수는 렉시컬 스코프다.

렉시컬 스코프 -> 함수를 어디서 호출했는지가 아니라 어디서 선언되었는지에 따라서 상위 스코프를 결정한다. 이게 렉시컬 스코프 이다.

```js
const x = 1;

function foo() {
  const x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo();
bar();
```

bar() 함수가 전역에 선언되어 있기 때문에 아무리 foo() 내에서 bar()를 실행시켰어도 ,
bar() 함수는 x = 1 이라는 값을 찍어준다.

즉 , 함수의 상위 스코프는 함수가 어디서 선언되었는지가 결정한다.

## 24.2 함수 객체의 내부 슬롯[[Environment]]

함수는 자신이 호출되는 환경과는 상관없이 자신이 정의된 환경 , 즉 상위 스코프(함수 정의가 위치하는 스코프가 바로 상위 스코프)를 기억해야 한다.

함수는 자신의 내부 슬롯 [[Environment]]에 자신이 정의 된 환경 , 즉 상위 스코프의 참조를 저장한다.

-> 그니까 함수가 생성 되면 [[Environment]] 라는 내부 슬롯이 생기는데 이떄 함수 평가 단계에서 스코프가 결정되는데 이거를 Environment 슬롯에 담아 뒀다가 나중에 함수 실행 단계에서

기억한 스코프를 꺼내서 쓰는 ? 이런 원리로 돌아가는 거 같다.

->

1. 코드 평가 단계에서 bar()함수가 등록이 되고 , 이때 Environment에 스코프가 등록이 됨,
2. 실행될때는 평가해놓은 것을 실행만 시키는 것이기 떄문에 foo()함수라는 스코프를 인식자체가 되지 않음.

### 24.3 클로저와 렉시컬 환경

```js
const x = 1;

function outer() {
  const x = 10;
  const inner = function () {
    console.log(x);
  };
  return inner;
}

const innerFunc = outer();
innerFunc();
```

위 코드에서 outer() 를 실행하면 inner() 함수를 리턴해고 outer 함수 가 종료된다.

inner 함수가 실행될 시점에는 outer함수는 종료되어있지만 , outer 함수의 10이 콘솔에 찍힌다.

외부함수 보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다.

-> 자바스크립트 모든 함수는 자신의 상위 함수를 기억함 <-

outer 함수가 종료될 때 실행 컨텍스트는 종료가 되지만 렉시컬 환경까지 종료가 되지는 않는다.

inner [[Environment]] -> outer함수 렉시컬 환경을 참조하고 있다. 그렇기에 outer함수는 누군가가 참조하고 있기 때문에 가비지컬렉터 대상이 되지 않는다.

클로저 성립 성질

1. 외부 함수 렉시컬 환경을 참조하고 있어야 한다.
2. 외부 함수보다 중첩 함수가 더 오래 생존을 해야 한다.

근데 이때 브라우저는 최적화를 통해서 상위 렉시컬 환경를 다 기억하는게 아니라 참조하고 있는 식별자(변수)만을 기억한다.

### 24.4 클로저의 활용

클로저는 상태가 의도치 않게 변경되지 않도록 안전하게 은닉하고 , 특정 함수에게만 상태 변경을 허용하여 상태를 안전하게 변경하고 유지하기 위해 사용합니다.

```js
const counter = (function () {
  // 카운트 상태 변수
  let num = 0;

  // 클로저인 메서드를 갖는 객체를 반환한다.
  // 객체 리터럴은 스코프를 만들지 않는다.
  // 따라서 아래 메서드들의 상위 스코프는 즉시 실행 함수의 렉시컬 환경이다.
  return {
    // num: 0, // 프로퍼티는 public하므로 은닉되지 않는다.
    increase() {
      return ++num;
    },
    decrease() {
      return num > 0 ? --num : 0;
    },
  };
})();

console.log(counter.increase()); // 1
console.log(counter.increase()); // 2

console.log(counter.decrease()); // 1
console.log(counter.decrease()); // 0
```

위 예제와 같이 중첩함수 위에 상위 함수는 리턴되어 소멸되어도 counter 렉시컬 스코프에 등록되어 있기 때문에 num 변수에 안전하게 접근이 가능하다. !

클로저 -> 외부 상태 변경이나 가변 데이터를 피하고 불변셩을 지향하는 함수형 프로그래밍에서 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이기 위해 클로저는 적극적으로 사용된다.

클로저를 사용하면 클로저가 반환하는 함수만의 독자적인 렉시컬 환경을 가질 수 있다.
